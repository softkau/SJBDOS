2023-02-25
	[sprintf 심볼 누락 오류]
		linker에 -lc 옵션을 빼서 linker가 libc 라이브러리 심볼 탐색을 하지 않아 일어남
2023-03-11
	[new 심볼 누락 오류]
		-lc++ 옵션이 있어야됨... 아니 글쓴이 이것도 설명 안 해주고 뭐하노!!
2023-03-14
	[인터럽트 에러]
		struct의 bit 수를 잘못 지정해줌...;
		asm도 잘못 작성함 (asm할 때는 정신차리고 코딩하자)
2023-03-19
	[UEFI에서 메모리관리를 OS로 이동]
		STACK 영역이동
			- entry point를 .asm의 한 루틴으로 지정한다
			- rsp 레지스터를 적당히 큰 공간에 배치(extern으로 .cpp에 선언된 빈 공간을 .asm에서 참조한다)
			- KernelMain을 호출한다
		Segment 설정
			- Global Descriptor(GDT)를 설정해준다 (null, code segment, data segment)
			- segment descriptor는 segment.hpp에 선언되어 있다
			- x64 모드에는 segment descriptor의 base, limit, granularity 멤버는 무시된다.
			- code_segment.type - DescriptorType::ExecuteRead
			- data_segment.type - DescriptorType::ReadWrite
			- ds, es, fs, gs는 사용하지 않는다(0으로 초기화)
			- ss <- 데이터 세그먼트로 지정
			- cs <- 코드 세그먼트로 지정(가장 마지막에 지정해야됨)
		Paging 설정
			- 4계층 구조
			- PML4 table -> PDP table -> Page Directory -> Page Table
			- cr3 <- PML4 table로 지정
		UEFI 메모리 맵 정보를 MemoryManager에 넘김
			- descriptor가 참조하지 않는 영역, IsAvailable이 아닌 영역은 모두 allocated로 마크한다
			- IsAvailable인 영역은 빈공간이다
			- 총 메모리 크기를 구한다
2023-06-28
	[뻘글]
		오랜만에 OS 작업하는 듯
		생각보다 재밌네
		아직 빌드만 해봐서 어떻게 동작할진 몰?루
		전체적으로 시스템 관련보단 UI 프로그래밍인 듯
		내일이나 내일 모레 빌드 동작 확인하고 소스코드 정리해야 할 듯
	[Layer Manager 업그레이드]
		기타
			- 전반적으로 책 내용이랑 비슷하게 코드 수정함(살짝살짝 다른게 헷갈림)
			- 윈도우 출력(Window Class말고 흔히 말하는 그 윈도우 맞다)
		Flickering 줄이기 위한 최적화
			- FrameBuffer에 일부분만 복사하는 기능 추가
			- Window에 일부분만 복사하는 기능추가
			- LayerManager에서 Draw시 ID를 특정해서 해당 영역만 업데이트 가능
			- 전체적으로 좀 복잡해짐
		Flickering 제거
			- Double Buffering (책에서는 Back Buffer라고 언급하긴 함)구현
			- 이건 대신 성능이 좀 느려지긴 함
	[MouseObserver 업그레이드]
		드라이버 업데이트
			- displacement x, y 이외에 버튼 이벤트(클릭)를 매개변수로 받을 수 있게 됨
		드래깅 기능
			- 클릭시 draggable 속성의 Layer는 이동시킬 수 있음
	[MakeFile 수정]
		일부 .o 파일 삭제 불가 해결
			- find ./build -type f -name '*.o' -delete
			- rm -rf로는 특정 확장자 파일을 재귀적으로 삭제하는 것이 불가능
			- 따라서 find로 삭제해야함
2023-10-15
	[뻘글]
		진짜 오랜만 엌ㅋㅋㅋㅋ
	[Timer 인터럽트 셋팅]
		PERIODIC 모드로 변경
		Timer 인터럽트 Handler를 인터럽트 벡터에 등록
		컴파일 확인 완료
	[TimerManager 제작]
		이것저것 만드는 중
		아직 컴파일 확인 안 함
2023-11-05
	[bug-fixing]
		마우스 움직일 때 '잔상'이 남는 현상 발견...
		스스로 함 찾아보자
		일단 Transparency가 켜져 있을 때만 Draw가 이상하게 발생함을 발견 (Draw 쪽 문제인 듯 싶다)
		찾았다! 복붙 잘못하다가 width가 들어갈 자리에 height가 들어감... 엄...
2023-11-09
	[bug-fixing]
		no_caller_saved_registers 를! 걸면
		자꾸 Tick에서 튕긴다...
		뭐가 문젤까...
		그냥 Tick 에서는 카운트만 하고 바깥에서 CurrentTick으로 받는게 차라리 낫지 않을까...?
		ㅁ?ㄹ
		이유는 잘 모르겠지만 걍 포기함 -> no caller saved registers는 빼자
2023-11-12
	[bug-fixing]
		console에서 BG_COLOR가 적용되지 않는 버그 제거
		refresh에서 clear가 없어서 그런 듯(배경색을 한 번도 입혀주지 않아서)
	[REALTIME Timer]
		ACPI PM 타이머란 것을 이용해서 LAPIC 타이머 초당 tick수를 측정
		-> 논리적 tick을 설정
		이제 Timer를 0.01초 단위로 설정할 수 있음(정확하진 않은 듯)
	[키보드 입력]
		간단하게 키보드 인터럽트를 받아서 콘솔에 출력
		이제 키보드로 글자를 적을 수 있다!
		shift 처리도 구현 완료
		-정상 동작 확인-
2023-11-25
	체력검정 끝
	통과 ㄱㅇㅈㅇㄱ
	오늘은 텍스트 박스 점멸 구현해보자
	[커서 점멸 구현]
		별거 없다
		근데 깜빡 거리는 게 조금 불안정한데 VNC 렉인지 잘 모르겠다...
		그래픽이 버벅이는데 그래픽을 전부 CPU가 처리해서 그런 건가 싶다
	[멀티테스크 구현 시작]
		흠...
		일단 SwitchContext 함수 프로토콜만 선언해둠
		구현은 ASM으로 하는 듯
2023-11-26
	[협력적 멀티테스크 구현]
		SwitchContext를 통해 서로 콘텍스트 스위칭을 함
		InitTaskB 실행 안 하고 돌렸다가 튕김...
		의외로 1트에 성공
	[선점형 멀티테스크 부분적 구현]
		일단 되긴 하는데...
		TaskB는 이동시키면 잔상이 남음...;
		느낌상 이런 거 같음
		-> TaskB를 렌더링 하기 직전 ContextSwitch가 발생
		-> MainTask(TaskA)에서 TaskB의 이동이 일어남
		-> TaskB로 다시 스위치 되었을 때 이전 장소에 그대로 렌더링
		-> 바로 다음 루프부턴 현재 위치에서만 렌더링이 일어남
		흠... 일단 osbook_day13b까지 하긴 했는데 원본에서도 이 현상이 있는지는 확인해봐야할 듯
	[sleep & wakeup 구현 중]
		sw 키로 sleep wakeup 트리거 기능 구현 중
		근데 안 된다...
2023-11-30
	병자기개발비 12만원 놓쳤다...
	[sleep & wakeup 구현]
		IdleTask를 넣어놔야하는데 TaskB로 전부 줬으니까
		당연하게도 안 멈추는 거였다
		구현에는 문제 없는듯
		* TaskB 잔상 이슈는 이후 책에서 언급하는데 데이터 경합 현상이라서
		Draw를 TaskB에서 제거하면 된단다
	[main queue 제거 중]
		task에 자체적으로 큐가 저장되어 있음
2023-12-01
	책에 나온 코드 안 보고 미리 짜보는 연습 중
	근데 저자가 생각하는 알고리즘이랑 내가 생각하는 거랑 많이 달라서
	계속 고치게 되는 듯
	[선점형 멀티테스크 구현 완료]
		꽤 재밌는 듯
		일단 현재 TaskB는 SW 키 입력으로 Wake / Sleep 할 수 있음
		IdleTask 1개는 쭉 Wake 상태긴 한데 우선순위가 최하라서 계속 대기 상태
		MainTask는 마우스 입력 / 키보드 입력 / 타이머 인터럽트 시 Wakeup 하고 -> 처리가 끝나면 Sleep
		주석 좀 추가함
	[TaskB 잔상 이슈 해결]
		main task에 메세지를 보내서 TaskB에서 Draw 이벤트 발생시 main task에서 작업할 수 있게 만듦
		FillRect, WriteString 등은 TaskB의 Layer 안에서 발생하는 것이므로 데이터 경합이 발생하지 않음
2023-12-02
	Task를 직접 생성 못하게 막음 (반드시 NewTask를 통해 생성할 것)
	터미널 모양 띄우는 거 함
2023-12-03
	서버 상태가 심히 안 좋다...
	터미널 화면 업데이트 안 되는 버그 생겨가지고 고치려고 하는데
	(main_task 전체화면이 업데이트 되는 이벤트 발생 시 같이 업데이트가 되는 거 보니까 Window 내부 버퍼에는 잘 그려지고 main_task에 Layer 인터럽트 보내는 부분에서 문제가 생기는 듯)
	서버도 자꾸 내려가고 머리 아파서 내일 해야할 듯
2023-12-05
	터미널 화면이 업데이트 안 되는 버그 수정함
	(LayerOperation을 지정 안 해줘서 & w, h 값을 제대로 지정 안 해줘서 screen에 렌더링 안 되는 거였음)
	커서 안 깜빡 거리는 거 해결
	(main task에서 switch 문에 break 안 걸어놔가지고 KeyPush 메세지가 무한정으로 들어와져서 커서 인터럽트가 실행 안 되던 것)
	커맨드 추가하는 건 내일 근무 갔다와서 추가해야징
2023-12-07
	초기에 터미널 화면이 활성화되어 있는데 TaskB 윈도우에 가려지는 현상
	증상: TaskB 활성화 후 다시 터미널 활성화하면 정상화됨
	그냥 넘어가기에는 너무 거슬려서 디버그해보기로 함
	* 가정1. MouseLayer 가 초기화 되지 않은 상태에서 ActiveLayer를 써서
	-> Log 떡칠해본 결과 Active는 Mouse가 초기화되고 난 후 사용해도 동일 증상 발생
	* 가정2. ContextSwitching 과정에서 layerstack이 손상되었다
	-> 그렇다치곤 너무 정상동작함 / 그리고 로그 결과 새로운 사실을 알아냄
	*** hidden -> visible 상태가 되는 경우 딱 depth 위치에 layer가 layer stack에 들어간다
	*** visible -> visible 인 경우 depth + 1 위치에 존재하게 된다
	둘이 다른 결과가 나므로 마우스 클릭으로 비활성화/활성화 되는 건 정상적으로 되지만,
	초기의 hidden 상태에서 활성화가 되는 경우 원하는 depth보다 -1 낮아 마우스를 제외한 레이어 1개 아래에 내려가게 된다
	따라서 SetDepth 의 동작을 전부 일관적으로 depth + 1 위치에 삽입하는 동작으로 변경한다
	=> 버그 해결됨
	아따 디버거 없이 코딩하는 거 어렵구마잉
	[기타 디버깅]
		터미널 linebuf_index가 제대로 업데이트 안 되는 거 수정함
		가끔 터미널 바탕화면 색깔이 뿌옇게 나올 때가 있는데 이건 왜 그런지 모르겠음
		-> 부팅할 때마다 다름 ㄷㄷ
	[터미널 커맨드 히스토리]
		방향키로 최대 10개까지 조회 가능
		10개 이상 입력하기 전에는 빈 커맨드가 조회되는데 나중에 수정할 듯
	[TaskB 제거]
		이제 얘는 빼도 될 듯
2023-12-20
	[자작 디버깅? 기능 구현]
		활성화 레이어가 없을 때 s키를 누르면
		마우스 포인터가 가리키고 있는 위치의 색깔 값을 읽어옴
		나중에 바탕화면 색이 이상하게 나올 때 색깔 코드 값을 확인해볼 예정
		참고로 정상일 때 색깔값은 #2d76ed임
	[fat disk 생성]
		/dev/zero로 0으로 초기화된 파일 생성
		mkfs.fat로 FAT 형식의 파일 시스템 초기화
		마운트 하는 거 해봄
		안에 텍스트 파일 2개 넣는 거 해봄
2023-12-21
	[FAT32 구조체 작성]
		책에 나온 표 보고 다 만듦
		겁내 노가다임.. 후...
		ls 커맨드 조만간 만들 수 있을 듯!
2023-12-22
	[LFN 구현중]
		책에 없는 내용 직접 구현해보기
		아직 다 구현 안 됨...
		https://wiki.osdev.org/FAT#Long_File_Names
		여기 참고 중

2023-12-23
	[LFN 부분구현 & ls 구현]
		16비트 char에서 앞 8비트만 잘라내서 출력하는 식으로 구현함
		어짜피 UTF-16 폰트가 있는 것도 아니라서 굳이 UTF-16 출력을 구현할 필요는 아직 없는 듯함
		lfn 구현이 되었으므로 KERNEL.ELF가 아니라 kernel.elf로 정상출력됨
		ls -v 하면 엔트리 정보 보이게 설정함
	[FindFileByName 구현 & cat 구현]
		ls에서 사용한 코드형태보다 좀 더 깔끔한 형태로 LFN 처리하는 방법 도입
		내가 생각해도 개잘짠 듯ㅋ
		ls 처리부분도 아마 추후 변경될 듯
	[app 실행 구현?]
		구현은 했는데
		앱을 디스크에 복사하는 스크립트 아직 안 만들어서 나중에 확인해봐야 할 듯...
2023-12-24
	[LFN 버그 및 코드 리팩토링]
		iterator 형식으로 간단하게 접근할 수 있는 DirectoryEntryPointer 구조체 작성
		살짝 성능이 떨어질 수도 있긴 할 텐데
		클러스터 끝부분에서 다음 클러스터로 넘어가는 부분을 이제 고려 안 해도 되어서
		심각하게 느려지는 수준이 아니라면 이득이라 판단됨 ㅎㅎ
		LFN 값을 읽을 때 복붙 잘못해서 name0만 읽는 버그가 있었음...
		다행히 코드 리팩토링하다가 먼저 발견해서 머리 아픈 일은 없었던 듯
	[app 실행 가능해짐]
		일단 onlyhlt 정상 작동함
		cat kernel.elf 하면 터미널이 살짝 맛가는데 원래 이런건지 아닌건지 잘 모르겠음
		출력될 때 터미널을 잡고 흔들면 정상출력되는게 보이긴 함...
2023-12-27
	[app 실행 버그]
		flat binary가 아닌 elf 로드시 뻗음
		-s -S 옵션을 걸어 gdb로 확인해본 결과, 점프 위치가 이상한 곳으로 지정됨
		00000... 인 영역으로 날아가는데 흠....

		* ELF 규격에 맞춰서 리딩하면 일단 실행은 된다! (부트로더에서 커널 읽듯이 하면 됨)
		근데 + 연산을 하면 또 튕긴다...
		느낌상 파일 내부에서 absolute jump가 일어나는 곳이 있고
		거기를 지나갈 때 프로그램이 터지는게 아닐까 생각해본다

		일단 가상메모리 구현을 하면 알 수 있을 거 같다
		그나저나 LoadELF 함수 만들었는데 책 뒤쪽에서 구현하고 있다... (예측맨 ㄷㄷ)
2023-12-30
	[app 실행 버그 원인 규명]
		rpn 파일을 덤프했을 때

    		1357:	0f be 11             	movsx  edx,BYTE PTR [rcx]
    		135a:	83 c2 d6             	add    edx,0xffffffd6             <- $edx -= 42
    		135d:	83 fa 05             	cmp    edx,0x5                    
    		1360:	0f 87 c8 00 00 00    	ja     142e <main+0x19e>          <- if (*(rcx) > 47) == 사칙연산 기호가 아닌 경우 default로 점프
    		1366:	4c 63 d7             	movsxd r10,edi
    		1369:	4a 8b 0c d5 40 24 00 	mov    rcx,QWORD PTR [r10*8+0x2440]
    		1370:	00 
    		1371:	ff 24 d5 58 01 00 00 	jmp    QWORD PTR [rdx*8+0x158]    <- jmp 테이블인 것 같은데 유효한지는 ㅁ?ㄹ 일단 edx가 42 빼졌으니깐 0부터 시작할 거고 일단 hexdump해서 0x158 위치를 조사해봐야할 듯

		요런 부분이 있다.
		0x1371 커맨드가 제일 수상하다.
		gdb로 확인한 결과 엉뚱한 곳으로 날아가는 것을 확인

		뭐하는 놈이고 생각해보니 switch문과 연관이 있어보인다.
		0x1357 ~ 0x1371을 해석하면 '+', '-', '*', '/'에 해당하는 곳으로 점프하기 위한 코드임을 추측해볼 수 있다
		점프 테이블의 asm 구현을 생각해보면 0x158 위치에 점프 테이블이 있을 것으로 생각해봄이 심히 적절하다.

		                                   v 점프 테이블처럼 생겨먹었다!!
		00000150  00 00 00 00 00 00 00 00  78 13 00 00 00 00 00 00  |........x.......|
		00000160  fa 13 00 00 00 00 00 00  2e 14 00 00 00 00 00 00  |................|
		00000170  05 14 00 00 00 00 00 00  2e 14 00 00 00 00 00 00  |................|
		00000180  a8 12 00 00 00 00 00 00  00 00 00 00 00 00 00 00

		아니나 다를까 포인터?스러운 녀석들이 5개 존재한다. 두 entry는 같은 값을 가지고 있으니
		0x1378, 0x13fa, 0x142e, 0x1405 이렇게 각각 4개의 case에 대응되는 녀석들인 것으로 보인다.

		즉, 프로그램은 사칙연산을 하려고 시도할 때 1378, 13fa, 142e, 1405 주소로 날아갈려고 시도하지만!
		그곳에는 우리가 쓴 코드 따윈 존재하지 않을 것이다...(따흐흑)

		아무튼, 프로그램이 image-base 0에서 작동할 것을 전제로 만들어졌기에 튕기는 것
		각 프로그램마다 독립적인 페이징을 구현해서 제대로 된 메모리 주소에 로드하면 자연스럽게 해결될 문제로 확인된다

		굳이 규명할 필요가 있었나 싶지만, 아무튼 재밌었다 ㅎㅎ
		(alignment도 딱히 건드리진 않았는데 만약 vector가 애매한 곳에 할당된 경우, 튕길 수도 있을 듯)
2023-12-31
	[페이징 구현]
		앱마다 독립적인 페이징이 주어지는 구현은 아니고
		cmd에서 돌아가는 커맨드에 한정해서 캐노니컬 어드레스의 후반부에 페이지를 할당해서 링커 오류를 해결했다
		캐노니컬 어드레스 전반부는 커널용이다
		일단 이제 rpn 커맨드가 아주 잘 돌아간다
		CR3를 각 프로그램마다 따로 주는 건 좀 뒤에서 하는 듯
2024-01-01
	새해가 밝았어요~
	전역의 해가 왔어요~
	nm : 파일 속 심볼 탐색 커맨드 (굳이 gdb 들어가서 info line <심볼> 검색 안 해도 되니까 편할 듯)
	ex) nm -C kernel/build/kernel.elf | grep printk (-C는 C++ 심볼 디맹글 옵션이다)
	시스템콜 구현 중...
2024-01-02
	일단 왠진 모르겠지만 CallApp(CS,SS를 수정해서 실행권한을 낮춤)을 호출하면 튕기는 거 같다...
	나중에 GDB로 확인해봐야겠다
	현재 빌드 기준 0x121999가 엔트리 포인트다
2024-01-03
	보니까 infinite loop가 최적화 당해버려서 rpn에서 커널 영역으로 돌아올려고 하기 때문인 것으로 확인됨
	근본적인 문제는 아니긴 한데 일단 rpn 수정 좀 해야할 듯
	volatile 변수를 써서 최적화는 최대한 피해보았다 (근데 그냥 jmp로 되어있는 거 보면 상관없는 거 같기도...)
	안에다 hlt를 넣었더니 CPU 예외가 발생해서 이상한 곳으로 튕긴다
	아마 interrupt handler 같기도
	일단 hlt 뺐는데 dump 상에서는 루프는 잘 살아있다
	-> 됐다!! 이제 안 튕김...
	user 모드에서는 hlt 커맨드는 못 쓰나 보다
	[TSS 구현]
		별거 없긴 한데 일단 구현함
2024-01-13
	휴가 복귀...
	두 달 숨참 어캄??
	[TSS 사용에 따른 rsp0 복귀 위치 수정]
		SwitchContext와 다르게 콘텍스트를 복원만 하는 RestoreContext를 추가함
		인터럽트 발생시 tss의 스택을 공유하기 때문에 복귀 위치가 이상해질 수 있음
		따라서 이 경우에는 인터럽트 핸들러 종료 위치로 복귀하는 콘텍스트를 핸들러 단에서 생성하고 SwitchTask 내부에서 RestoreContext를 호출하는 걸로 변경
		Sleep 같은 경우 인터럽트 핸들러로 인해 호출되는 메소드가 아니므로 이전과 동일하게 SwitchContext를 사용한다.
	[interrupt frame]
		~/osbook/interrupt_frame 에 일단 블로그 글 긁어옴...
		뭐가 엄청 많네...
2024-01-14
	[fault handler]
		템플릿이랑 매크로 사용해서 구현함
	[부팅시 강종됨...]
		InitializeTSS에 브레이크 포인트 걸어놓고 테스트 해보았는데
		LoadTR에서 터지는 걸 확인
		-> TSS 값을 3번 쉬프트해서 설정하는 걸 깜빡했다...
		근데 이제 GP 오류 발생하는데 뭐지
		IntHandlerLAPICTimer에서 fxrstor에서 터지는데 이유가
		alginment / 잘못된 segment 레지스터 값 설정
		reserved된 레지스터 영역을 건드릴 때
		GPF 오류가 발생할 수 있다고 한다...
	[해당 문제 해결]
		책에서 pop rax 하나를 빼먹어서 생긴 문제였다...
		(fxrstor [rsp]를 하면서 rsp 위치가 중요해지는데 pop rax를 안 하면 xmm/ymm 레지스터를 복원하는데 사용되는 메모리 위치가 어긋나게 된다)
		좀 얼탱이가 없는 문제였다
		아무튼 이제 페이지폴트 등 다양한 예외에 대해 커널에서 로그를 뽑아낼 수 있다
		rsp0 설정이 제대로 들어가는지 확인 좀 해봐야 할 듯
		디버거로 값을 읽어보니까 제대로 들어간 거 맞는 듯
2024-01-15
	[SYSCALL 구현]
		이제 syscall 제대로 동작한다!
		계속 UD 에러 떠서 확인해보니 wrmsr을 wrsmr으로 오타 내서 발생했었다...
		아니 왜 컴파일된 거임???
	[색깔 칙칙하게 나오는 버그 재발견]
		그래서 s키로 색깔값을 확인해보니 멀쩡하다..
		vnc 문제거나, framebuffer 처리 부분 자체에 문제가 있을지도... 큰 문제는 아니니까 나중에 확인해보자
	[syscall 도중 인터럽트에 대해서] 
		21.1 장에서 글쓴이 CR3가 전환되면서 유저 영역의 PML4이 비활성화되어 폴트가 발생해야 한다고 한다
		글쓴이의 논리대로라면, syscall 처리 도중 테스크가 전환되면 우선순위 레벨 0->0 전이가 발생하여 rsp0를 사용하지 않게 되고
		앱 스택 상에서 참조가 지속적으로 발생하게 될 것이다
		이 상태에서 CR3가 전환되면 앱 스택 영역의 PML4가 비활성화되며(*) OS가 뻗어버려야 한다.

		근데 내가 기억하기로 앱이 실행되든, 테스크가 전환되든, CR3를 변경하는 구조는 아직 존재하지 않는다
		현재까지로는 SetCR3는 초반 OS 영역의 페이지맵을 생성할 때 제외하곤 호출되지 않는다
		따라서 OS, 앱 전부 같은 CR3 값을 사용하기 때문에 PML4가 비활성될리가 없다고 생각한다.

		처리에 아주 시간이 오래 걸리는 syscall(LongHlt)을 구현하고 실행해보았다
		syscall 도중 타이머 인터럽트(테스크 전환)가 발생해도 OS가 안 뻗는다.

		따라서 21.1에서 상황을 잘못 설명한 것으로 보인다
		책에서도 개발 30일째에(거의 끝부분이다) 버그가 발생한 걸 고치기 위해 보충한 내용이라고 한다
		하지만 현재 상황에서는 발생할리가 없는 버그이고 'CR3가 전환된다' 라는 내용은
		좀 혼동을 주는 말이 아닐까 싶다;

		어찌됐든 IST 구현은 하기로 했다...
	[IST 구현]
		TSS에서 RSP0 설정했던 것처럼 IST 설정도 간단하다
		특정 인터럽트 핸들러에 대해 특정 stack 영역을 사용하도록 강제할 수 있는데 (CS 3 -> 0 같은 상황이 아니라면..?)
		MakeIDTAttr 에서 마지막 인자에 사용할 IST 번호를 설정할 수 있다
		0을 주면 IST를 사용하지 않는 인터럽트 핸들러.. 인 것이다
2024-01-18
	[-O0에서 오작동...]
		왜 인지는 모름...
		일단 CopyLoadSegements을 할 때 갑자기 튕기기 시작해서
		최적화 레벨을 낮춘 뒤 실행해보았는데,
		이번에는 LAPICTimerStart에서 GP를 발생시켰다
		일단 컴파일러가 생성한 코드를 보니 엉뚱한 곳에 쓰기를 시도하는 코드가 생성되어 있었다
		좀 얼탱이가 없긴 한데 왜 이런 코드가 나왔는지 좀 알아봐야 할 것 같다...
2024-01-19
	[-O0 되게 만들기 day1]
		-O2일 때랑 비교해보았는데,
		-O0에서는 initial_count 변수(포인터)를 직접 참조한 뒤, 그값을 포인터로 참조한다.
		따라서 특별히 문제는 없어야 되는데...
		문제는 initial_count가 KernelMain 진입시 손상되어버린다!!!
		내 생각에는 컴파일러가 볼 때 더이상은 쓸모없는 변수라 생각했던 건지 덮어씌워도 된다고 판단한게 아닐까 싶다
		그래서 이 값을 손상시키면 안 된다고 분명하게 표현하기 위해 const를 붙였다
		(스택 영역에서는 const가 생성된 asm에 특별한 효과를 주진 않지만 이건 전역 변수의 const이기 때문에 유의미한 차이를 만들 것이다)
		이 결과 $0xfee00380에 직접 대입하는 걸로 코드가 변경 되었다 ㄷㄷ

		-> 이제 rpn 실행하기 전까지 문제없이 작동된다!!!
	[PF 분석]
		CopyLoadSegements에서 페이지 폴트가 발생한다
		멀쩡하던 곳이 왜 갑자기 이러는지는 잘 몰?루겠지만
		memcpy에서 두번째 LOAD 세그먼트를 로드할 때 튕기는 걸 확인했다
		총 11개의 페이지가 할당되고 dst, src 위치는 정확한 걸 확인했으니...
		아마 SetupPageMaps에서 삑사리 났을 가능성이 99%...
		바이너리가 비교적 작은 winhello는 되고 stars, rpn 등은 안 되는 거 보니 페이징 이슈 맞는 듯하다
2024-01-20
	[추가 버그 수정]
		이전에 initial_count가 손상되던게 마음에 걸렸다
		뭔가 stack 영역이 잘못 지정된 게 아닌가 생각이 들었는데
		오늘 확인해보니 컴파일러가 코드를 이상하게 생성해놓은 걸 확인했다
		rsp가 stack의 끝이 아닌 뭔가 이상한 위치에 설정되어 있었다
		main.cpp의 [[ auto stack_begin = reinterpret_cast<uint64_t>(stack) + SIZE ]]을 참조하는 asm 코드가 있었는데
		엄밀히 따지면 UB라 컴파일러가 지멋대로 해석해서 rsp 가 이상한 곳으로 가버린 듯하다
		그냥 asm 코드에 커널 스택 위치에 1024 * 1024을 더 해주는 걸로 해결했다
		근데 여전히 페이지 폴트가 발생한다... 흠...
	[rpn 할당 위치 확인]									[페이지]
		LOAD #1 : 0xffff800000000000 ~ 0xffff800000001a84	0, 1 (2개)
		LOAD #2 : 0xffff800000002a90 ~ 0xffff80000000d811	2, 3, 4, 5, ... C, D (12개...??)
		LOAD #3 : 0xffff80000000e820 ~ 0xffff80000000fd68	E, F (2개)
		뭔가 좀 이상한게 지난번에는 LOAD #2 할당할 때 num_4kpages가 11개였던 걸로 기억... 어???
		LOAD #2 같은 경우는 위치가 저렇게 되어서 ceil(memsz / page_size)으론 부족한 걸로 보임
		일단은 +1해서 페이지 수가 모자라진 않게 해보았다
		rpn, large 등 동작이 이제 된다!! ㄷㄷ
		근데 large 2는 안 튕기는데 1234는 튕긴다...
		근데 지금은 또 안 튕긴다... 아 몰랑! 일단은 해결된 걸로
	[-O2로 복귀]
		-O0에선 페이지 할당에 한세월 걸렸는데 -O2에선 금방된다!!! ㄷㄷ
		large 1234 커맨드 여러번 실행해보았는데 멀쩡한 거 보면 일단은 괜찮은 듯...?
2024-01-21
	[기타 시스템콜]
		DrawLines, ReadEvent 구현
2024-01-24
	ReadEvent 추가 구현
	마우스 이벤트 구현
2024-01-26
	RM 커맨드 잘못쳤다가 ELFAPP 시스템 콜 파일들이 날아가버렸다...
	다음부턴 LS로 꼭 확인하고 실행시키자...
	mikanos 원본 소스로 일부 복원했다
	하는 김에 LongHlt(0x02)는 시스템 콜에서 제외시켰고 그 결과 그 이후 시스템 콜 번호들이 한 칸씩 앞으로 당겨졌다
	paint 추가 구현
	UD 뜨길래 뭐고 했는데 0x0a에 ReadEvent를 등록했는데 시스템콜은 0x10을 호출해서 발생했었다
	내일 야간 뛰고 와서 타이머랑 애니메이션 프로그램 만들어야겠다
	오늘은 여기까지... 이거 찍턴 전까지 다 할 수는 있을까...?
2024-01-27
	[*나중에 해볼 거*]
		CRT0 구현 -> C RunTime (startup routine)
		구현해서 링커에다가 주면 이제 main 함수를 일반적으로 호출하고 종료할 수 있을 것 같다.
		참고: https://wiki.osdev.org/Creating_a_C_Library
	[타이머 시스템콜 구현]
		몇가지 실수로 동작이 안 되었는데
		일단 해결함!
	[큐브 렌더링 앱 구현]
		일단 소스코드 거의 안 보고 그냥 알고 있는 걸로 코딩함
		느리기도하고 조금 깨지긴 하는데 구현 성공한 듯
2024-01-28
	[큐브 앱 최적화 및 디버깅]
		rasterization 과정에 한 픽셀당 4개의 ccw가 계산되어야하는 문제가 있음
		인터넷 검색 결과 인접한 픽셀은 상수값을 더하는 것으로 ccw값을 구할 수 있다(선형..적이다고 해야하나)
		따라서 불필요한 곱셈 연산을 대거 없앰으로서 좀 앱이 안정적으로 돌아가게 되었다
		z 버퍼가 이상하게 계산되는 것 또한 확인
		백터 * 행렬 곱을 계산할 때 벡터를 meset으로 초기화하는데
		Vector3D가 아니라 Vector2D 크기로 초기화해서 생긴 문제였음
		어짜피 큐브의 3면만 눈앞에서 보이기 때문에 나머지 3면은 렌더링하지 않기로 했다
		SIMD도 써보고 싶지만 일단은 보류..
		어쩌면 행렬 곱셈 고속화를 해야할지도...?
	[벽돌깨기 게임 포팅]
		이건 진짜 만들기 귀찮아서
		mikanos에서 -돚거- 해왔다
		일단 정상 동작하는 것을 확인
2024-01-29
	[페이징 전환]
		이제 앱(정확히는 태스크)마다 개별 페이지 구조를 가진다!
		구현은 생각보다 별 거 없다
		1. 최상위 계층인 pml4 테이블 1개 할당한다
		2. cr3을 그걸로 설정한다
		(설정 전에! 앱에서도 시스템콜 등 커널 영역을 써야 되기 때문에 커널 pml4의 초반 0 ~ 255부분은 신규 pml4에 복사한다)
		(포인터를 복사하는 거기 때문에, 하위계층은 딱히 복사할 필요가 없다...)
		(또한 콘텍스트에서 cr3을 os pml4->앱 pml4로 변경해줘야 한다)

		앱 종료시 os pml4로 복구시켜준다
	[noterm 명령 구현]
		터미널 레이어를 비활성화한 상태로 앱을 런칭한다
		그런데 뭔가 좀 구현이.. 좀 야매스럽다
		나중에 터미널도 커널에서 분리시키고 앱 런칭 기능은 Task에 넣도록 변경해야할 듯
2024-01-31
	[CPL=3에서 폴트 발생시 앱 강종]
		핸들러에다가 KillApp 기능을 추가해줬다
		근데 이거 디버거로 돌리면 frame 값이 괴상하게 나온다...
		뭐지...
		일단 인터럽트 핸들러(ISR)에서 디버깅을 하는 건 썩 좋지 않기 때문에
		로깅을 하라는 스택오버플로우의 답변이 있다
		일단 이건 나중에 해결해보기로...
		(cs 값이 디버거로 확인하면 이상하게 나오는데 로그로 찍어보면 정상적으로 나온다)
2024-02-04
	코드 리펙토링 및 디렉토리 탐색 기능 추가 (일단 잘 작동하는 듯)
2024-02-06
	페이지 폴트 이슈로 인해
	터미널 executefile 부분 수정사항은 원상복귀했다
	readfile 잘 동작하고, grep도 잘 동작하는 거 확인
	syscall에 포인터가 유저 영역을 가리키고 있는지 확인하는 sanity check 코드 추가
	리눅스에서는 유저 영역에서 없는 페이지를 접근할려고 할 때 처리가
		[가상 메모리 매니저에서 일일이 확인]
		..에서
		[일단 페이지 폴트 띄우게 하고 핸들러에서 처리]
		로 변경되었다고 한다
	나중에 구현해볼 듯
	[커서 버그]
		terminaldescriptor->read를 쓰면 커서 깜빡임이 멈춰버리는 버그가 생긴다...
		아마도! 터미널이 sleep 하는 동안 커서 타이머가 타임아웃하고
		그 인터럽트가 씹혀버리면서 커서 타이머가 재생성되지 않아 발생하는 것으로 보인다...
		나중에 고쳐볼 듯
2024-02-07
	[커서 버그에 관해]
		해결 방법으로 세가지를 생각해보았다
		1. 메인태스크에서 타이머를 관리한다
			-> 이 방법은 뭔가 마음에 안 든다
		2. 타이머를 다시 추가하지 않아도 되도록 periodic 타이머를 만든다
			-> 그나마 간단하긴 한데 이런 타이머는 제거가 난감하다 (태스크 전환 타이머가 이것과 비슷하긴 하다)
		3. 터미널 태스크와 프로그램 실행 태스크를 분리한다
			-> 이건 구현이 조금 복잡할 듯한데 이게 맞는 방향인 거 같다
		일단 책 전부 끝낼 때까지 보류하기로...
	[fd = 0/1/2, cp 구현]
		이제 파일디스크립터로 0, 1, 2 (stdin, stdout, stderr)를 쓸 수 있다!
		파일을 카피하는 cp 프로그램도 제작 완료
		정상 동작 확인됨
2024-02-08
	[dpage 커맨드 구현]
		dpage로 파일에 존재하는 특정 바이트값의 개수를 구할 수 있음
		큰 파일을 읽을 때 demand paging 검증을 할 수 있음
		std::vector로 테스트 해보았는데 정상 동작한다.
		처음에 코드를 쓸 때 0x1000 만큼 배열을 만들었더니 바로 프로그램이 강종되었는데
		stack overflow 때문인 걸로 보인다...
	[scrolling 버그 해결]
		프로그램이 동작 중일 땐 scrolling 제대로 되지 않는 사실을 발견
		scrolled 멤버변수를 추가해서 Scroll() 호출마다 scrolled 값이 true로 세팅되도록 변경
		scrolled 값이 true일 때마다 터미널 Inner 영역 전체를 렌더링 하도록 변경
2024-02-09
	[file mapping 구현]
		책 쭉 따라서 구현해서 큰 무리 없이 구현된 듯
	[copy on write 구현]
		동일한 파일을 로드할 때 메모리를 절약하는 알고리즘
		근데 구현이 꽤나 까다롭다...
		일단 멍때리면서 다 하긴 했는데 좀 찜찜한 구석이 있긴 한 듯

		그리고 os가 너무 갑갑하게 굴러가는 것도 이제 슬슬 신경 쓰인다
		cube 같은 렌더링이 바쁘게 돌아가는 프로그램은 다른 프로그램이랑 겹쳐있을 때 깨져서 보이기도 한다(;;)
		찍턴 때 실제 기계에서 돌려보면서(아니면 적어도 vnc없이 qemu 돌리면서) 손 좀 봐야할 것 같다
		cube 앱을 4개 구동하고 종료까지 되었는데
		전부 종료 후 다시 앱을 시작하면 os가 뻗어버린다...
		파일로드 map 구조에 등록만 하고 해제는 안 해서 그런가 생각이 들기도 하지만 원인이 사실 잘 ㅁ?ㄹ

		그리고 이론상 앱이 전부 종료되어도 temp_pml4는 어딘가 남아있어서 메모리 누수가 생겨야할 것 같지만
		memstat로 확인해보면 그런 건 없다...
		이것도 확인해봐야 할 것 같다

		일단 코드 정리 한번 싹 해줘야할 듯?
2024-02-10
	[메모리 회수 문제 일부 해결?]
		cube 최초 한 개 돌릴 때 23 프레임 정도를 잡아먹는다
		복수 구동 시 개당 10프레임 정도 먹는다
		종료시 5프레임 회수된다...?
		완전 종료시 9프레임 정도가 남는다. 그리고 이거 계속 쌓인다
		3개 실행하고 2개 종료했더니 커널 영역에서 페이지 폴트 발생(??)
		일단 코드가 이상해져서 그냥 원복함
		cube 코드도 다른 거 가져다 쓰니까 좀 빨리 돌아가는 듯
		Ctrl + Q 인식도 씹히던 거 새로운 cube 코드로 돌리니까 훨 나은 듯

		너무 머리 아프니 일단 무시하고 계속 진행해보자...
	[utf-8 지원]
		이제 일본어 출력 가능
		별로 중요한 부분은 아닌 것 같아서 걍 무지성으로 복붙함...
		나중에 한국어도 넣어봐야겠다
2024-02-11
	[리다이렉션 부분 지원]
		이제 > 해석 가능
	[새로운 버그]
		apps/grep Conv memmap > gr1 실행시 GP 발생 (rip가 엉뚱?한 곳으로 날아가버림)
		지금 syscall putstring 자체가 조금 이상한 듯
		아 또 뭐가 문제야!!!
		-> 커널 전체를 깔끔하게 clean 해주고 리빌드 했더니 해결
		(gdb 돌리니까 syscall 시 syscall::PutString이 호출 조차되지 않는 것으로 보아 최근에 스택 크기 만진게 링커 오류를 낸 듯)
		이 문제 해결할 수 있는 Makefile 설정이 있긴 한데 또 꼬일 것 같아서 나중에 고치기로 함
	[리다이렉션 코드 추가 후 utf8 오류]
		Print(char32_t)는 건드릴 거 없고
		Print(const char* s, optional<size_t> len) 내부를 변경할 필요가 있었다
		일단 코드 흐름상 len은 glyph/글자 개수가 아니라 실제 바이트 수로 해석해야 할 것 같다
		목표는 한 글자만 출력하는 Print(char32_t)에 s가 가리키고 있는
		utf8을 utf32로 적절히 변형하여 넘겨주고, s 포지션도 적절하게 utf8 길이만큼 뒤로 빼주면 된다
		적절하게 바꿔주니 다시 정상작동한다
2024-02-15
	[pipe 구현]
		파이프 디스크립터를 제작해서 이제 파이프도 사용 가능
		근데 apps/grep Conv @stdin | apps/grep 3E @stdin 같은 경우
		터미널이 무한 멈춰 버린다...
		나중에 다시 디버깅해보아야 할 듯
2024-02-16
	[pipe 버그 수정 #1]
		파이프가 2개 이상 쓰이면 생기는 버그였음
		auto it = waiter_tasks.find(task_id)로 멈춰있는(기다리고 있는) 태스크를 선택해서 깨워야 하는데
		auto it = waiter_tasks.begin()으로 엉뚱하게 작성해서
		파이프가 하나밖에 없을 때는 태스크가 종료될 수 있었지만
		파이프가 2개 이상일 때는 이상하게 동작할 수밖에 없었다...
		근데 stdout가 조금 이상하게 동작하는 거 같으므로 좀 더 손봐야할 듯
	[pipe 버그 수정 #2]
		포인터 어드레스로 보아 pipe 지정은 제대로 되는 듯하다
		pipe->Write()에서 buf + sent_bytes을 해줘야 하는데
		buf 선두부분만 읽고 보내버려서 생긴 문제였다
		결국 또 오타 이슈;;
		이제 정상적으로 동작한다!
2024-02-17
	[경로에 공백 제거]
		파일명 끝에 공백이 들어올 때 무시하는 기능 추가
		추가로 모든 파일 탐색은 파일명을 LFN으로 변환한 뒤 비교하는 것으로 변경함
	[시스템 콜 버그]
		syscall::ReadEvent 시 튕김현상 발생
		확인해보니 stack이 0xffff .... ffff60으로 지정되어 들어오는 버그...???
		tss가 제대로 지정되지 않아서 일까??
		-> 시스템콜 시 GetCurrentTaskOSStackPointer 이 함수를 거쳐서 os 스택을 가지고 오는데
		여기서 제대로 못가지고 오는 듯
		어셈블리 생성 결과를 보니 함수 내부에서는 $rax에 멀쩡하게 스택 포인터를 불러온다
		근데 함수 끝에서 레지스터들을 복원할 때 $rax도 복원해버린다;
		뭐지 싶은데 난 분명히 코드에서 리턴값을 명시했다
		clang이 그냥 뻘짓한 듯
		일단 -O2로 최적화 레벨을 올리면 pop rax는 사라지면서 버그가 사라진다... ㅇㅇ???
2024-02-18
	[no_caller_saved_registers 버그]
		-O0에서만 리턴값을 덮어씌워 버리는 거 같은데 진짜 왜 그러는 건지는 몰루??
		일단 -Og로 컴파일 해봐야 할 듯..?
		-Og는 괜찮은 듯! 디버깅할 때는 이걸로 해야겠다
		참고로 gcc에서는 해당 문제 없음(sse를 비활성화 해야하는 옵션을 추가로 걸어줘야하긴 함)
2024-02-20
	[0부터 시작하는 OS 자작입문 책 완료]
		마지막 tview 앱은 스스로 만들어보았는데
		왠지 잘 안 되기도하고 렉 걸려서 mikanos에서 복붙해왔다 (os 기능도 아니고)
		그래도 렉 걸리는 거 보니까 그냥 환경이 감자라서 그런 듯
		gview 앱은 진짜 그냥 귀찮아서 복붙했다

		둘 다 어쨌든 잘 동작한다
		이것으로 책 내용은 종료!!!

		일단 원본이랑 구동 비교해서 성능이 구려지는 이유라든지
		아무튼 그런 걸 좀 찾아야겠다
*** 찍턴 시작 *** (2024-03-10)
2024-03-13
	로컬로 파일 옮기는 중...
	개발 환경 다시 셋팅 중...
	https://wikidocs.net/164069
	^ 위 사이트에 절차가 나와있다.
	1. 빌드 repo clone
	2. ansible로 컴파일러, nasm 등의 개발툴들을 세팅한다.
		* llvm, lld clang 등 버전 최신화
		* qemu gui 세팅
		* llvm 14를 디폴트로 설정
		* EDK2 repo clone
		* EDK2 base tools
		* newlib C 표준라이브러리
		* DISPLAY VARIABLE 설정 (WSL1/WSL2)
	3. 근데 이거 정리 좀 할 필요가 있어보인다... 엄...
	지금 QEMU가 안 열린다...???
	DISPLAY 변수뿐만 아니라
	export LIBGL_ALWAYS_INDIRECT=1
	도 해줘야 QEMU가 열린다...

2025-03-09
  run 할 때 해줘야 하는 것:
    source ./devenv/buildenv.sh (빌드 환경변수 셋팅)
    APP_DIR=apps RESOURCE_DIR=resource (앱 로딩 및 폰트 로딩) ./build.sh run
  메모리 누수 현상 해결:
    text 창에서 sbrk를 미친 듯이 호출하는 현상이 발생했었음
    그 결과 text 창을 켜놓은 상태로 os를 방치하면 성능저하 및 뻗는 이슈가 발생함
    특이한 점은 physical memory는 전혀 늘지 않고 계속 out of memory가 먼저 터짐
    이 이유는 아직도 잘 모르겠음...

    일단 Draw Message를 switch 문 안쪽으로 넣었더니 해결됨.
    아마도 switch 문 바깥에 있게 되면 계속 draw를 호출하는 악순환이 발생하는 것으로 보임.
    이로 인해 task queue가 무한정 늘어나 메모리가 떨어진 것으로 추정됨.